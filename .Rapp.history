alpha.values<-seq(from= 0.1 , to= 100 , length.out=50)#
stop("replace the _______________ and delete this stop")#
#
#keep it simple (and slow) and do a for loop:#
likelihood.values <- rep(NA, length(alpha.values))#
for (iteration in sequence(length(alpha.values))) {#
	likelihood.values[iteration] <- OUwie.fixed(tree, trait, model="OUMV", alpha=rep(alpha.values[iteration],2), sigma.sq=best$solution[2,], theta=best$theta[,1])$loglik#
}
plot(x= alpha.values , y= likelihood.values, xlab="likelihood surface of alpha", ylab="_______________", type="l", bty="n")
points(x=best$solution[1,1], y=best$loglik, pch=16, col="red")
best$solution[1,1]
best$loglik
plot(x= alpha.values , y= likelihood.values, xlab="alpha", ylab="likelihood", type="l", bty="n")
points(x=best$solution[1,1], y=best$loglik, pch=16, col="red")
#keep it simple (and slow) and do a for loop:#
likelihood.values <- rep(NA, length(alpha.values))#
for (iteration in sequence(length(alpha.values))) {#
	likelihood.values[iteration] <- OUwie.fixed(tree, trait, model="OUMA", alpha=rep(alpha.values[iteration],2), sigma.sq=best$solution[2,], theta=best$theta[,1])$loglik#
}#
#
plot(x= alpha.values , y= likelihood.values, xlab="alpha", ylab="likelihood", type="l", bty="n")
best$solution
best$loglik
alpha.values<-seq(from= 0.1 , to= 100 , length.out=50)#
#
#keep it simple (and slow) and do a for loop:#
likelihood.values <- rep(NA, length(alpha.values))#
for (iteration in sequence(length(alpha.values))) {#
	likelihood.values[iteration] <- OUwie.fixed(tree, trait, model="OUMA", alpha=rep(alpha.values[iteration],2), sigma.sq=best$solution[2,], theta=best$theta[,1])$loglik#
}
plot(x= alpha.values , y= likelihood.values, xlab="alpha", ylab="likelihood", type="l", bty="n")
points(x=best$solution[1,1], y=best$loglik, pch=16, col="red")
text(x=best$solution[1,1], y=best$loglik, "unconstrained best", pos=4, col="red")
print(best) #prints info on best model
alpha.values<-seq(from= 0.1 , to= 100 , length.out=50)
best$solution
best$thet
best$theta
best$theta[,1]
best
best$theta
likelihood.values <- rep(NA, length(alpha.values))#
for (iteration in sequence(length(alpha.values))) {#
	likelihood.values[iteration] <- OUwie.fixed(tree, trait, model="OUMA", alpha=rep(alpha.values[iteration],2), sigma.sq=best$solution[2,], theta=best$theta[1,])$loglik#
}
plot(x= alpha.values , y= likelihood.values, xlab="alpha", ylab="likelihood", type="l", bty="n")
points(x=best$solution[1,1], y=best$loglik, pch=16, col="red")
best$theta
best$theta[1,]
best$theta[,1]
best
#keep it simple (and slow) and do a for loop:#
likelihood.values <- rep(NA, length(alpha.values))#
for (iteration in sequence(length(alpha.values))) {#
	likelihood.values[iteration] <- OUwie.fixed(tree, trait, model="OUMA", alpha=rep(alpha.values[iteration],2), sigma.sq=best$solution[2,], theta=c(57.68207, 1.049803e-13))$loglik#
}
likelihood.values
best$solution
best$solution[2,]
best$theta
best
best$theta[,1]
best$theta[1,]
values and plot the likelihood against this.#
alpha.values<-seq(from= 0.1 , to= 100 , length.out=50)#
#
#keep it simple (and slow) and do a for loop:#
likelihood.values <- rep(NA, length(alpha.values))#
for (iteration in sequence(length(alpha.values))) {#
	likelihood.values[iteration] <- OUwie.fixed(tree, trait, model="OUMA", alpha=rep(alpha.values[iteration],2), sigma.sq=best$solution[2,], theta=best$theta[1,])$loglik#
}
plot(x= alpha.values , y= likelihood.values, xlab="alpha", ylab="likelihood", type="l", bty="n")
likelihood.values
best
OUwie.fixed(tree, trait, model="OUMA", alpha=c(52.71079, 23.39027), sigma.sq=best$solution[2,], theta=best$theta[1,])$loglik
OUwie.fixed(tree, trait, model="OUMA", alpha=c(52.71079, 23.39027), sigma.sq=best$solution[2,], theta=best$theta[,1])$loglik
best
OUwie.fixed(tree, trait, model="OUMA", alpha=c(52.71079, 23.39027), sigma.sq=c(56005.45281, 56005.45281), theta=c(57.68207, 1.049803e-13))$loglik
best
#Next, keep all parameters but alpha at their maximum likelihood estimates (better would be to fix just alpha and let the others optimize given this constraint, but this is harder to program for this class). Try a range of alpha values and plot the likelihood against this.#
alpha.values<-seq(from= 0.1 , to= 100 , length.out=50)#
#
#keep it simple (and slow) and do a for loop:#
likelihood.values <- rep(NA, length(alpha.values))#
for (iteration in sequence(length(alpha.values))) {#
	likelihood.values[iteration] <- OUwie.fixed(tree, trait, model="OUMV", alpha=rep(alpha.values[iteration],2), sigma.sq=best$solution[2,], theta=best$theta[,1])$loglik#
}
#Next, keep all parameters but alpha at their maximum likelihood estimates (better would be to fix just alpha and let the others optimize given this constraint, but this is harder to program for this class). Try a range of alpha values and plot the likelihood against this.#
alpha.values<-seq(from= 0.1 , to= 100 , length.out=50)#
#
#keep it simple (and slow) and do a for loop:#
likelihood.values <- rep(NA, length(alpha.values))#
for (iteration in sequence(length(alpha.values))) {#
	likelihood.values[iteration] <- OUwie.fixed(tree, trait, model="OUMV", alpha=rep(alpha.values[iteration],2), sigma.sq=best$solution[2,], theta=best$theta[,1])$loglik#
}
plot(x= alpha.values , y= likelihood.values, xlab="alpha", ylab="likelihood", type="l", bty="n")
best$loglik
best
sigma.values<-seq(from= 0.1 , to= 100000 , length.out=50)
sigma.values<-seq(from= 0.1 , to= 100000 , length.out=50)#
#
#keep it simple (and slow) and do a for loop:#
likelihood.values <- rep(NA, length(sigma.values))#
for (iteration in sequence(length(sigma.values))) {#
	likelihood.values[iteration] <- OUwie.fixed(tree, trait, model="OUMA", alpha=best$solution[1,], sigma.sq=rep(sigma.values[iteration],2), theta=best$theta[,1])$loglik#
}
likelihood.values <- rep(NA, length(sigma.values))#
for (iteration in sequence(length(sigma.values))) {#
	likelihood.values[iteration] <- OUwie.fixed(tree, trait, model="OUMA", sigma.sq=best$solution[1,], alpha=rep(sigma.values[iteration],2), theta=best$theta[,1])$loglik#
}
best
values and plot the likelihood against this.#
sigma.values<-seq(from= 0.1 , to= 100000 , length.out=50)#
#
#keep it simple (and slow) and do a for loop:#
likelihood.values <- rep(NA, length(sigma.values))#
for (iteration in sequence(length(sigma.values))) {#
	likelihood.values[iteration] <- OUwie.fixed(tree, trait, model="OUMA", alpha=best$solution[1,], sigma.sq=rep(sigma.values[iteration],2), theta=best$theta[,1])$loglik#
}
plot(x= sigma.values , y= likelihood.values, xlab="sigma", ylab="likelihood", type="l", bty="n")
best$solution
points(x=best$solution[2,1], y=best$loglik, pch=16, col="red")
text(x=best$solution[2,1], y=best$loglik, "unconstrained best", pos=4, col="red")
abline(h=best$loglik-2, lty="dotted") #Two log-likelihood
sigma.values<-seq(from= 10000 , to= 100000 , length.out=50)#
#
#keep it simple (and slow) and do a for loop:#
likelihood.values <- rep(NA, length(sigma.values))#
for (iteration in sequence(length(sigma.values))) {#
	likelihood.values[iteration] <- OUwie.fixed(tree, trait, model="OUMA", alpha=best$solution[1,], sigma.sq=rep(sigma.values[iteration],2), theta=best$theta[,1])$loglik#
}#
#
plot(x= sigma.values , y= likelihood.values, xlab="sigma", ylab="likelihood", type="l", bty="n")#
points(x=best$solution[2,1], y=best$loglik, pch=16, col="red")#
text(x=best$solution[2,1], y=best$loglik, "unconstrained best", pos=4, col="red")
best$solution[2,1]
points(x=best$solution[2,1], y=best$loglik, pch=16, col="red")
best$loglik
sigma.values<-seq(from= 1000 , to= 100000 , length.out=50)#
#
#keep it simple (and slow) and do a for loop:#
likelihood.values <- rep(NA, length(sigma.values))#
for (iteration in sequence(length(sigma.values))) {#
	likelihood.values[iteration] <- OUwie.fixed(tree, trait, model="OUMA", alpha=best$solution[1,], sigma.sq=rep(sigma.values[iteration],2), theta=best$theta[,1])$loglik#
}#
#
plot(x= sigma.values , y= likelihood.values, xlab="sigma", ylab="likelihood", type="l", bty="n")
points(x=best$solution[2,1], y=best$loglik, pch=16, col="red")
text(x=best$solution[2,1], y=best$loglik, "unconstrained best", pos=4, col="red")
abline(h=best$loglik-2, lty="dotted") #Two log-likelihood
alpha.values<-seq(from= 0.1 , to= 100 , length.out=50)#
#
#keep it simple (and slow) and do a for loop:#
likelihood.values <- rep(NA, length(alpha.values))#
for (iteration in sequence(length(alpha.values))) {#
	likelihood.values[iteration] <- OUwie.fixed(tree, trait, model="OUMV", alpha=rep(alpha.values[iteration],2), sigma.sq=best$solution[2,], theta=best$theta[,1])$loglik#
}
best$logLik
best
names(best)
best$loglik
plot(x= alpha.values , y= likelihood.values, xlab="alpha", ylab="likelihood", type="l", bty="n", ylim=c(min(likelihood.values, best$loglik)))
plot(x= alpha.values , y= likelihood.values, xlab="alpha", ylab="likelihood", type="l", bty="n", ylim=c(min(likelihood.values), best$loglik))
points(x=best$solution[1,1], y=best$loglik, pch=16, col="red")
text(x=best$solution[1,1], y=best$loglik, "unconstrained best", pos=4, col="red")
abline(h= best$loglik-2, lty="dotted") #Two log-likelihood
require("akima")
install.packages("akima")
require("akima")
nreps<-400
theta1.points<-c(best$theta[1,1], rnorm(nreps-1, best$theta[1,1], 5*best$theta[1,2])) #center on optimal value, have extra variance
theta2.points<-c(best$theta[2,1], rnorm(nreps-1, best$theta[2,1], 5*best$theta[2,2])) #center on optimal value, have extra variance
likelihood.values<-rep(NA,nreps)
for (iteration in sequence(nreps)) {#
	likelihood.values[iteration] <- OUwie.fixed(tree, trait, model="OUMV", alpha=best$solution[1,], sigma.sq=best$solution[2,], theta=c(theta1.points[iteration], theta2.points[iteration]))$loglik#
}
likelihood.differences<-(-(likelihood.values-max(likelihood.values)))
interpolated.points<-interp(x=theta1.points, y=theta2.points, z= likelihood.differences, linear=FALSE, extrap=TRUE, xo=seq(min(theta1.points), max(theta1.points), length = 400), yo=seq(min(theta2.points), max(theta2.points), length = 400))
contour(interpolated.points, xlim=range(c(theta1.points, theta2.points)),ylim=range(c(theta1.points, theta2.points)), xlab="Theta 1", ylab="Theta 2", levels=c(2,5,10),add=FALSE,lwd=1, bty="n", asp=1)
max(theta1.points)
max(theta2.points)
points(x=trait$X[which(trait$Reg==1)],y=rep(min(c(theta1.points, theta2.points)), length(which(trait$Reg==1))), pch=18, col=rgb(0,0,0,.3)) #the tip values in regime 1, plotted along x axis
points(y=trait$X[which(trait$Reg==2)],x=rep(min(c(theta1.points, theta2.points)), length(which(trait$Reg==2))), pch=18, col=rgb(0,0,0,.3)) #the tip values in regime 2, plotted along y axis
library(phytools)
trait.ordered<-data.frame(trait[,2], trait[,2],row.names=trait[,1])
trait.ordered
trait
trait <- data.frame(species=tree$tip.label, elevation= as.integer(cleaned.discrete$data[,2]+1), aggregation=as.numeric(cleaned.continuous$data[,1]))
#You can use code you wrote for the correlation exercise here.#
setwd("~/Desktop/2016Spring/Phylometh/ContinuousTraits")#
#
source("ContinuousFunctions.R")#
tree <- read.tree("eucTree.tre")#
tree$tip.label <- gsub("_"," ", tree$tip.label); tree$tip.label[8] <- "E. tenuiramis"#
discrete.data <- read.csv(file="eucDataDiscretized.csv", stringsAsFactors=FALSE, row.names=1) #death to factors.#
continuous.data <- read.csv(file="eucDataContinuous.csv", stringsAsFactors=FALSE, row.names=1) #death to factors.#
#
cleaned.continuous <- CleanData(tree, continuous.data)#
cleaned.discrete <- CleanData(tree, discrete.data)#
VisualizeData.continuous(tree, cleaned.continuous)#
VisualizeData.discrete(tree, cleaned.discrete)#
#
#First, start basic. What is the rate of evolution of your trait on the tree? #
#
BM1 <- fitContinuous(tree, cleaned.continuous$data, model="BM")#
print(paste("The rate of evolution is", round(BM1$aggregation$opt$sigsq, 2)/50000000, "in units of", "number of changes per million years (given that the tree age is 50 MY)"))#
#Important: What are the rates of evolution? In what units?#
#OUwie runs:#
#This takes longer than you may be used to. #
#We're a bit obsessive about doing multiple starts and in general#
#performing a thorough numerical search. It took you 3+ years#
#to get the data, may as well take an extra five minutes to #
#get an accurate answer#
#
discreteTrait <- data.frame(species=tree$tip.label, elevation= as.integer(cleaned.discrete$data[,2]+1)) #
#
treeAncER <- rayDISC(tree, discreteTrait, model="ER", node.states="marginal")#
treeAncSYM <- rayDISC(tree, discreteTrait, model="SYM", node.states="marginal")#
treeAncARD <- rayDISC(tree, discreteTrait, model="ARD", node.states="marginal")#
c(treeAncER$AICc, treeAncSYM $AICc, treeAncARD $AICc) # Use Equal Rates model#
#
trait <- data.frame(species=tree$tip.label, elevation= as.integer(cleaned.discrete$data[,2]+1), aggregation=as.numeric(cleaned.continuous$data[,1]))
trait.ordered<-data.frame(trait[,2], trait[,2],row.names=trait[,1])
trait.ordered
trait.ordered<- trait.ordered[tree$tip.label,]
trait.ordered
z<-trait.ordered[,1]
names(z)<-rownames(trait.ordered)
tree.mapped<-make.simmap(tree,z,model="ER",nsim=1)
leg<-c("black","red")
names(leg)<-c(1,2)
plotSimmap(tree.mapped,leg,pts=FALSE,ftype="off", lwd=1)
simmapBased<-OUwie(tree.mapped,trait,model="OUMV", simmap.tree=TRUE, diagn=FALSE)
print(simmapBased)
OU1 <- fitContinuous(tree, cleaned.continuous, model="OU")
cleaned.continuous
OU1 <- fitContinuous(tree, cleaned.continuous$data, model="OU")
par(mfcol(c(1,2)))
plot(tree, show.tip.label=FALSE)
ou.tree <- rescale(tree, model="OU", 1)
plot(ou.tree)
par(mfcol(c(1,2)))
par(mfcol=c(1,2))
plot(tree, show.tip.label=FALSE)
ou.tree <- rescale(tree, model="OU", 1)
plot(ou.tree)
ou.tree <- rescale(tree, model="OU", 10)
plot(ou.tree)
OU1 <- fitContinuous(tree, cleaned.continuous$data, model="OU")#
par(mfcol=c(1,2))#
plot(tree, show.tip.label=FALSE)#
ou.tree <- rescale(tree, model="OU", 10)#
plot(ou.tree)
names(ou.tree)
AIC(ou.tree)
names(OU1)
OU1$aggregation
names(OU1$aggregation)
AIC(OU1$aggregation)
? fitContinuous
OU1$aggregation$opt
OU1$aggregation$opt$aic
AIC.BM1 <- BM1$aggregation$opt$aic
AIC.OU1 <- OU1$aggregation$opt$aic
delta.AIC.BM1 <- AIC.BM1-min(c(AIC.BM1, AIC.OU1))
delta.AIC.BM1
delta.AIC.OU1 <- AIC.OU1-min(c(AIC.BM1, AIC.OU1))
delta.AIC.OU1
cleaned.discrete
cleaned.discrete$data[,1]
one.discrete.char <- cleaned.discrete$data[,1]
reconstruction.info <- ace(one.discrete.char, tree, type="discrete", method="ML", CI=FALSE)
reconstruction.info
best.states <- colnames(reconstruction.info)[apply(reconstruction.info$lik.anc, 1, which.max)]
colnames(reconstruction.info)
reconstruction.info
reconstruction.info$lik.anc
?ace
position <- c(0, rep(NA,ngen))
ngen=1000
position <- c(0, rep(NA,ngen))
position
plot(sequence(ngen), position, type="l", bty="n")
ngen=1000#
position <- c(0, rep(NA,ngen))#
for (i in sequence(ngen)){#
	position[i+1] <- position [i] + rnorm(1)#
}#
plot(sequence(ngen), position, type="l", bty="n")
sequence(ngen)
position
plot(sequence(ngen+1), position, type="l", bty="n")
library(ape) #utility fns#
library(geiger) #utilty fns#
library(OUwie)#
library(fBasics)#
#
#You can use code you wrote for the correlation exercise here.
phy <- read.tree("eucTree.tre")
phy $tip.label <- gsub("_"," ", phy $tip.label); phy $tip.label[8] <- "E. tenuiramis"
data <- read.csv(file="eucDataContinuous.csv", stringsAsFactors=FALSE, row.names=1) #death to factors.
data
Dat <- treedata(phy, data, sort=TRUE)$data
Phy <- treedata(phy, data, sort=TRUE)$phy
pic1<-pic(Dat[,1], Phy)
pic2<-pic(Dat[,2], Phy)
pic1
for(i in 1:length(pic1)){#
		if(pic1[i]){#
			pic1[i] <- pic1[i]*(-1)#
			pic2[i] <- pic2[i]*(-1)#
		}#
	}
pic1
pic1<-pic(Dat[,1], Phy)#
	pic2<-pic(Dat[,2], Phy)
pic1
pic1<-pic(Dat[,1], Phy)#
	pic2<-pic(Dat[,2], Phy)#
	pic1pos <- pic1#
	pic2pos <- pic2
for(i in 1:length(pic1)){#
		if(pic1[i]<0){#
			pic1pos[i] <- pic1[i]*(-1)#
			pic2pos[i] <- pic2[i]*(-1)#
		}#
	}
pic1pos
pic2pos
normalTest(pic1pos)
mod <- lm((pic2pos) ~ 0 +(pic1pos))
plot(pic1pos, pic2pos, xlim=c(0, max(pic1pos)), ylim=c(min(pic2pos), max(pic2pos)), main="Regression of positivized phylogenetic independent contrasts"); abline(mod)
mod
print("Regression results"); print(summary(mod))
source("CorrelationFunctions.R")
tree <- read.tree("eucTree.tre")
tree $tip.label <- gsub("_"," ", tree $tip.label); tree $tip.label[8] <- "E. tenuiramis"
discrete.data <- read.csv(file="eucDataDiscretized.csv", row.names=1, stringsAsFactors=FALSE) #death to factors.
continuous.data <- read.csv(file="eucDataContinuous.csv", row.names=1, stringsAsFactors=FALSE) #death to factors.
contrasts.answer <- RunContrasts(tree, continuous.data)
pagel94.answer <- RunPagel94(tree, discrete.data)
Dat <- treedata(phy, data, sort=TRUE)$data
Phy <- treedata(phy, data, sort=TRUE)$phy
modBM <- phylolm(Dat[,2] ~ Dat[,1], phy=Phy, model="BM")
modBM
if(summary(modBM)$coefficients[2,4] > 0.05){#
		print(paste("Hypothesis test returns a p-value of ", round(summary(modBM)$coefficients[2,4],3), ", meaning that the evolution of traits is not correlated.", sep=""))#
	}else{#
		print(paste("Hypothesis test returns a p-value of ", round(summary(modBM)$coefficients[2,4],3), ", meaning that the evolution of traits is correlated.", sep=""))#
		}
pagel94.answer <- RunPagel94(tree, discrete.data)
pagel94.answer
pagel94.answer <- RunPagel94(tree, discrete.data)
source("CorrelationFunctions.R")
pagel94.answer <- RunPagel94(tree, discrete.data)
discrete.data
Dat <- treedata(phy, data, sort=TRUE)$data
Phy <- treedata(phy, data, sort=TRUE)$phy
discrete.data
data
pagel94.answer <- RunPagel94(tree, continuous.data)
data <- read.csv(file="eucDataDiscretized.csv", row.names=1, stringsAsFactors=FALSE)
data
Dat <- treedata(phy, data, sort=TRUE)$data
Phy <- treedata(phy, data, sort=TRUE)$phy
Dat[,2]
Dat[,1]
modBM <- phylolm(Dat[,2] ~ Dat[,1], phy=Phy, model="BM")
modBM
if(summary(modBM)$coefficients[2,4] > 0.05){#
		print(paste("Hypothesis test returns a p-value of ", round(summary(modBM)$coefficients[2,4],3), ", meaning that the evolution of traits is not correlated.", sep=""))#
	}else{#
		print(paste("Hypothesis test returns a p-value of ", round(summary(modBM)$coefficients[2,4],3), ", meaning that the evolution of traits is correlated.", sep=""))#
		}
source("CorrelationFunctions.R")
contrasts.answer <- RunContrasts(tree, continuous.data)
contrasts.answer
pagel94.answer <- RunPagel94(tree, discrete.data)
discrete.data
Dat[,1]
Dat <- treedata(phy, data, sort=TRUE)$data
Phy <- treedata(phy, data, sort=TRUE)$phy
Dat
setwd("~/Desktop/2016Spring/Phylometh/ContinuousTraits")#
#
source("ContinuousFunctions.R")#
tree <- read.tree("eucTree.tre")#
tree$tip.label <- gsub("_"," ", tree$tip.label); tree$tip.label[8] <- "E. tenuiramis"#
discrete.data <- read.csv(file="eucDataDiscretized.csv", stringsAsFactors=FALSE, row.names=1) #death to factors.#
continuous.data <- read.csv(file="eucDataContinuous.csv", stringsAsFactors=FALSE, row.names=1) #death to factors.#
#
cleaned.continuous <- CleanData(tree, continuous.data)#
cleaned.discrete <- CleanData(tree, discrete.data)#
VisualizeData.continuous(tree, cleaned.continuous)#
VisualizeData.discrete(tree, cleaned.discrete)#
#
#First, start basic. What is the rate of evolution of your trait on the tree?
BM1 <- fitContinuous(tree, cleaned.continuous$data, model="BM")
print(paste("The rate of evolution is", round(BM1$aggregation$opt$sigsq, 2)/50000000, "in units of", "number of changes per million years (given that the tree age is 50 MY)"))
round(BM1$aggregation$opt$sigsq, 2)
BM1
round(BM1$ala.Elevation$opt$sigsq, 2)
print(paste("We don't know the rate of evolution because branch lengths are scaled to add up to a tree height of 1"))
print(paste("round(BM1$aggregation$opt$sigsq, 0)"))
print(paste(round(BM1$aggregation$opt$sigsq, 0)))
source("ContinuousFunctions.R")
tree <- read.tree("eucTree.tre")
tree$tip.label <- gsub("_"," ", tree$tip.label); tree$tip.label[8] <- "E. tenuiramis"
discrete.data <- read.csv(file="eucDataDiscretized.csv", stringsAsFactors=FALSE, row.names=1) #death to factors.
continuous.data <- read.csv(file="eucDataContinuous.csv", stringsAsFactors=FALSE, row.names=1) #death to factors.
cleaned.continuous <- CleanData(tree, continuous.data)
continuous.data
cleaned.continuous <- CleanData(tree, continuous.data[,c(2,4)])
cleaned.continuous
BM1 <- fitContinuous(tree, cleaned.continuous$data, model="BM")
BM1 <- fitContinuous(tree, log(cleaned.continuous$data), model="BM")
print(paste("The rate of evolution of mean elevation is", round(BM1$aggregation$opt$sigsq, 2), "change in log elevation per arbitrary time unit"))
print(paste("The rate of evolution of mean elevation is", round(BM1$ala.Elevation$opt$sigsq, 2), "change in log elevation per arbitrary time unit"))
BM1
print(paste("The rate of evolution of mean elevation is", round(BM1$ala.Elevation$opt$sigsq, 2), "change in log meters per arbitrary time unit"))
print(paste("The rate of evolution of range envelope is", round(BM1$range.envelope$opt$sigsq, 2), "change in log square kilometers per arbitrary time unit"))
